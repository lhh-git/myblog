(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{384:function(n,a,t){"use strict";t.r(a);var s=t(45),e=Object(s.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"this绑定规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this绑定规则"}},[n._v("#")]),n._v(" this绑定规则")]),n._v(" "),t("p",[n._v("this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定，this最终指向调用它的对象。\n"),t("a",{attrs:{href:"https://www.cnblogs.com/echolun/p/11962610.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("this指向"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"默认绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认绑定"}},[n._v("#")]),n._v(" 默认绑定")]),n._v(" "),t("h3",{attrs:{id:"函数调用模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数调用模式"}},[n._v("#")]),n._v(" 函数调用模式")]),n._v(" "),t("p",[n._v("当一个函数并非一个对象的属性时，那么它就是被当做函数来调用的。在此种模式下，this被绑定为全局对象，在浏览器环境下就是window对象（非严格模式）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var lastName = \"刘\"\nfunction fn() {\n  var name = \"海\"\n  console.log(this.name)                    // ''\n  console.log(this)                         // Window \n  console.log(this.lastName)                // '刘'\n  this.alert()                              // 可调用执行\n}\nfn()\n这个例子中无论函数声明在哪，在哪调用，由于函数调用时前面并未指定任何对象，这种情况下this指向全局对象window。\n")])])]),t("h3",{attrs:{id:"严格模式环境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#严格模式环境"}},[n._v("#")]),n._v(" 严格模式环境")]),n._v(" "),t("p",[n._v("在严格模式环境中，默认绑定的this指向undefined")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fn() {\n  \"use strict\";\n  console.log(1,this);                       // undefined\n  console.log(2,this.name);                  // Cannot read property 'name' of undefined\n}\nvar name = '听风是风'\nfn() \n")])])]),t("h2",{attrs:{id:"隐式绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐式绑定"}},[n._v("#")]),n._v(" 隐式绑定")]),n._v(" "),t("h3",{attrs:{id:"方法调用模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法调用模式"}},[n._v("#")]),n._v(" 方法调用模式")]),n._v(" "),t("p",[n._v("当函数被保存为一个对象的属性时，它就可称为这个对象的方法。当一个方法被调用时，this被绑定到这个对象上。如果调用表达式包含一个提取属性的动作（. 或 []），那么它被称为方法调用")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var lastName = \"刘\"\nvar obj = {\n  name: \"海\",\n  say: function() {\n    console.log(1, this)                    // {name: '海', say: ƒ}\n    console.log(2, this.lastName)           // undefined\n    console.log(3, this.name)               // '海'\n  } \n}\nobj.say()\n")])])]),t("h2",{attrs:{id:"显示绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#显示绑定"}},[n._v("#")]),n._v(" 显示绑定")]),n._v(" "),t("p",[n._v("显式绑定是指我们通过call、apply以及bind方法改变this的行为")]),n._v(" "),t("h3",{attrs:{id:"call"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[n._v("#")]),n._v(" call:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("例1：\nvar lastName = \"刘\"\n  var obj = {\n    name: \"obj\",\n    say: function() {\n      console.log(this)                       // {name: 'obj2'}\n      console.log(this.lastName)              // undefined\n      console.log(this.name)                  // 'obj2'\n    } \n  }\n  var obj2 = {\n    name: 'obj2'\n  }\n  var obj3 = {\n    name: 'obj3'\n  }\n  obj.say.call(obj2)\n\n例2：\nvar lastName = \"刘\"\nvar obj = {\n  name: \"obj\",\n  say: function() {\n    console.log(1, this)                        // {name: 'obj3', run: ƒ}               \n    console.log(2, this.lastName)               // undefined\n    console.log(3, this.name)                   // 'obj3'\n    this.run()\n  } \n}\nvar obj2 = {\n  name: 'obj2'\n}\nvar obj3 = {\n  name: 'obj3',\n  run: function() {\n    console.log(`${this.name}正在跑步`)           // obj3正在跑步\n  }\n}\nobj.say.call(obj3)\n")])])]),t("h3",{attrs:{id:"apply"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[n._v("#")]),n._v(" apply:")]),n._v(" "),t("p",[n._v("与call用法相同")]),n._v(" "),t("h3",{attrs:{id:"bind"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[n._v("#")]),n._v(" bind:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("例1：与call用法相同+()执行   \nobj.say.bind(obj3)()\n例2：\nvar lastName = \"刘\"\nvar obj = {\n  name: \"obj\",\n  say: function() {\n    console.log(1, this)                        // {name: 'obj3', run: ƒ}               \n    console.log(2, this.lastName)               // undefined\n    console.log(3, this.name)                   // 'obj3'\n    this.run()\n  } \n}\nvar obj2 = {\n  name: 'obj2'\n}\nvar obj3 = {\n  name: 'obj3',\n  run: function() {\n    console.log(`${this.name}正在跑步`)           // obj3正在跑步\n  }\n}\nconst obj4 = obj.say.bind(obj3)\nobj4()\n")])])]),t("h2",{attrs:{id:"new绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new绑定"}},[n._v("#")]),n._v(" new绑定")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function Fn(){\n    this.name = '听风是风';\n};\nlet echo = new Fn();\necho.name                                         //听风是风\n")])])]),t("h2",{attrs:{id:"this绑定优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this绑定优先级"}},[n._v("#")]),n._v(" this绑定优先级")]),n._v(" "),t("h3",{attrs:{id:"为什么显式绑定不和new绑定比较呢-因为不存在这种绑定同时生效的情景-如果同时写这两种代码会直接抛错"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么显式绑定不和new绑定比较呢-因为不存在这种绑定同时生效的情景-如果同时写这两种代码会直接抛错"}},[n._v("#")]),n._v(" 为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("显式绑定 > 隐式绑定 > 默认绑定\n\nnew绑定 > 隐式绑定 > 默认绑定\n")])])]),t("h2",{attrs:{id:"箭头函数的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的this"}},[n._v("#")]),n._v(" 箭头函数的this")]),n._v(" "),t("p",[n._v("ES6的箭头函数是另类的存在，为什么要单独说呢，这是因为箭头函数中的this不适用上面介绍的四种绑定规则")]),n._v(" "),t("p",[n._v("箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("例1:\nfunction fn() {\n  return () => {\n      console.log(this.name);\n  };\n}\nlet obj1 = {\n  name: '听风是风'\n};\nlet obj2 = {\n  name: '时间跳跃'\n};\nlet bar = fn.call(obj1);                          // fn this指向obj1\nbar.call(obj2);                                   // 听风是风\n为啥我们第一次绑定this并返回箭头函数后，再次改变this指向没生效呢？\n\n前面说了，箭头函数的this取决于外层作用域的this，fn函数执行时this指向了obj1，所以箭头函数的this也指向obj1。\n除此之外，箭头函数this还有一个特性，那就是一旦箭头函数的this绑定成功，也无法被再次修改，有点硬绑定的意思\n\n例2:\n当然，箭头函数的this也不是真的无法修改，我们知道箭头函数的this就像作用域继承一样从上层作用域找，\n因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。\nfunction fn() {\n    return () => {\n        console.log(this.name);\n    };\n};\nlet obj1 = {\n    name: '听风是风'\n};\nlet obj2 = {\n    name: '时间跳跃'\n};\nfn.call(obj1)();                                // fn this指向obj1,箭头函数this也指向obj1\nfn.call(obj2)();                                // fn this 指向obj2,箭头函数this也指向obj2\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);