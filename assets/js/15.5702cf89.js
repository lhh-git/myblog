(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{380:function(a,n,l){"use strict";l.r(n);var t=l(45),s=Object(t.a)({},(function(){var a=this,n=a.$createElement,l=a._self._c||n;return l("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[l("h2",{attrs:{id:"call"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[a._v("#")]),a._v(" call")]),a._v(" "),l("p",[a._v("call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 obj.run.call(obj2, '北京', '上海', ...)。")]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("var obj = {\n  name: '小刘',\n  age: '18',\n  run: function(local, finish) {\n    console.log(`${this.name}今年${this.age}岁，来自${local}去往${finish}`)  // 小王今年28岁，来自北京去往上海\n  }\n}\n\nvar obj2 = {\n  name: '小王',\n  age: '28',\n  run: function() {\n    console.log(`${this.name}今年${this.age}岁，来自${local}去往${finish}`)\n  }\n}\n\nobj.run.call(obj2, '北京', '上海')\n")])])]),l("h2",{attrs:{id:"apply"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[a._v("#")]),a._v(" apply")]),a._v(" "),l("p",[a._v("apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入，\n且当第一个参数为null、undefined的时候，默认指向window(在浏览器中)，使用apply方法改变this\n指向后原函数会立即执行，且此方法只是临时改变thi指向一次")]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("apply 的所有参数都必须放在一个数组里面传进去 obj.run.apply(obj2, ['北京', '上海', ...])。\n\nvar obj = {\n  name: '小刘',\n  age: '18',\n  run: function(local, finish) {\n    console.log(`${this.name}今年${this.age}岁，来自${local}去往${finish}`)  // 小王今年28岁，来自北京去往上海\n  }\n}\n\nvar obj2 = {\n  name: '小王',\n  age: '28',\n  run: function() {\n    console.log(`${this.name}今年${this.age}岁，来自${local}去往${finish}`)\n  }\n}\n\nobj.run.apply(obj2, ['北京', '上海'])\n")])])]),l("h2",{attrs:{id:"bind"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[a._v("#")]),a._v(" bind")]),a._v(" "),l("p",[a._v("bind：语法和call一模一样，区别在于立即执行还是等待执行，bind不兼容IE6~8")]),a._v(" "),l("p",[a._v("bind与apply和call的最大的区别是：bind不会立即调用，而是返回一个新函数，称为绑定函数，\n其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函\n数的参数来调用原函数")]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("var obj = {\n  name: '小刘',\n  age: '18',\n  run: function(local, finish) {\n    console.log(`${this.name}今年${this.age}岁，来自${local}去往${finish}`)  // 小王今年28岁，来自北京去往上海\n  }\n}\n\nvar obj2 = {\n  name: '小王',\n  age: '28',\n  run: function() {\n    console.log(`${this.name}今年${this.age}岁，来自${local}去往${finish}`)\n  }\n}\n\nobj.run.bind(obj2, '北京', '上海')()\n")])])]),l("h2",{attrs:{id:"区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[a._v("#")]),a._v(" 区别：")]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("1、三者都可以改变函数的this对象指向。\n2、三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。\n3、三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。\nbind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。\n")])])]),l("h2",{attrs:{id:"具体区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#具体区别"}},[a._v("#")]),a._v(" 具体区别：")]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，这也是为什么上方例子中bind后还加了一对括号 ()的原因。\n2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。\n3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，因为apply在执行时还要多一步解析数组。\n")])])]),l("h2",{attrs:{id:"使用场景"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[a._v("#")]),a._v(" 使用场景：")]),a._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("1、当我们使用一个函数需要改变this指向的时候才会用到call，apply，bind如果你要传递的参数不多，\n则可以使用fn.call(thisObj, arg1, arg2 ...)\n如果你要传递的参数很多，则可以用数组将参数整理好调fn.apply(thisObj, [arg1, arg2 ...])\n2、如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用\nconst newFn = fn.bind(thisObj); newFn(arg1, arg2...)\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);